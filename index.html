<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 圣诞手势交互 - 手机优化版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050a10; font-family: sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        .input_video { display: none; }
        
        #ui-overlay {
            position: absolute; top: 10%; width: 100%; text-align: center;
            color: #f0c27b; z-index: 10; pointer-events: none;
            text-shadow: 0 0 15px rgba(240, 194, 123, 0.8);
        }
        
        #debug-info {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: rgba(0,0,0,0.5); color: #0f0; padding: 10px; font-family: monospace;
            font-size: 12px; pointer-events: none; border-radius: 4px;
        }

        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 10, 16, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; color: white;
        }
        #start-btn {
            padding: 15px 40px; font-size: 1.2rem; background: #c41e3a; color: white;
            border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 0 20px #c41e3a;
        }
    </style>
</head>
<body>

    <div id="debug-info">状态: 等待启动...</div>

    <div id="start-screen">
        <h1 style="color: #f0c27b;">MERRY CHRISTMAS</h1>
        <p>推荐使用 Safari 或 Chrome 浏览器</p>
        <button id="start-btn">开启圣诞之旅</button>
    </div>

    <div id="ui-overlay">
        <h1>MERRY CHRISTMAS</h1>
        <p>— 伸开手掌释放星光，握紧拳头凝聚树影 —</p>
    </div>

    <div id="canvas-container"></div>
    <video class="input_video" playsinline muted></video>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        let scene, camera, renderer, particles;
        let targetPositions = [], currentPositions = [];
        let handOpenness = 0;
        const debugInfo = document.getElementById('debug-info');
        const particleCount = 8000; // 手机端平衡性能与效果

        function getTreePoint() {
            const h = Math.random() * 12;
            const maxR = (12 - h) * 0.35 + (Math.random() * 0.3);
            const angle = Math.random() * Math.PI * 2;
            const r = Math.pow(Math.random(), 1.5) * maxR;
            return { x: Math.cos(angle) * r, y: h - 6, z: Math.sin(angle) * r };
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(particleCount * 3);
            const cols = new Float32Array(particleCount * 3);
            const colorPalette = [0xffd700, 0xff0000, 0x228b22, 0xffffff];

            for (let i = 0; i < particleCount; i++) {
                const p = getTreePoint();
                targetPositions.push(p);
                currentPositions.push({x: p.x, y: p.y, z: p.z});
                pos[i*3] = p.x; pos[i*3+1] = p.y; pos[i*3+2] = p.z;
                const c = new THREE.Color(colorPalette[Math.floor(Math.random()*4)]);
                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));

            particles = new THREE.Points(geo, new THREE.PointsMaterial({
                size: 0.12, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8
            }));
            scene.add(particles);
        }

        let smoothOpen = 0;
        function animate() {
            requestAnimationFrame(animate);
            smoothOpen += (handOpenness - smoothOpen) * 0.1;
            const posArr = particles.geometry.attributes.position.array;
            const exp = 1 + smoothOpen * 6;

            for(let i=0; i < particleCount; i++) {
                posArr[i*3] += (targetPositions[i].x * exp - posArr[i*3]) * 0.1;
                posArr[i*3+1] += (targetPositions[i].y * exp - posArr[i*3+1]) * 0.1;
                posArr[i*3+2] += (targetPositions[i].z * exp - posArr[i*3+2]) * 0.1;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y += 0.005;
            renderer.render(scene, camera);
        }

        async function startSystem() {
            debugInfo.innerText = "状态: 正在加载模型并请求摄像头...";
            const videoElement = document.querySelector('.input_video');
            
            try {
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({ 
                    maxNumHands: 1, 
                    modelComplexity: 0, 
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const lm = results.multiHandLandmarks[0];
                        const d = Math.sqrt(Math.pow(lm[8].x-lm[0].x,2) + Math.pow(lm[8].y-lm[0].y,2));
                        handOpenness = Math.max(0, Math.min(1, (d - 0.12) * 4));
                        debugInfo.innerText = "状态: 识别中 - 张开度 " + handOpenness.toFixed(2);
                        debugInfo.style.color = "#0f0";
                    } else {
                        handOpenness = 0;
                        debugInfo.innerText = "状态: 未检测到手势";
                        debugInfo.style.color = "#f00";
                    }
                });

                const cameraInstance = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: 480, height: 640
                });
                
                await cameraInstance.start();
                document.getElementById('start-screen').style.display = 'none';
                initThree();
                animate();
            } catch (e) {
                debugInfo.innerText = "错误: " + e.message;
                console.error(e);
            }
        }

        document.getElementById('start-btn').addEventListener('click', startSystem);
        
        window.addEventListener('resize', () => {
            if(camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
